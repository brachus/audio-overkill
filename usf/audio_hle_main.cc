
#include "usf.h"
#include "audio_hle.h"
#include "memory.h"
#include "plugin.h"
// "Mupen64 HLE RSP plugin v0.2 with Azimers code by Hacktarux"

u32 inst1, inst2;

u32 SEGMENTS[0x10];	// 0x0320
u16 AudioInBuffer;	// 0x0000(T8)
u16 AudioOutBuffer;	// 0x0002(T8)
u16 AudioCount;		// 0x0004(T8)
s16 Vol_Left;		// 0x0006(T8)
s16 Vol_Right;		// 0x0008(T8)
u16 AudioAuxA;		// 0x000A(T8)
u16 AudioAuxC;		// 0x000C(T8)
u16 AudioAuxE;		// 0x000E(T8)
u32 loopval;		// 0x0010(T8) // Value set by A_SETLOOP : Possible conflict with SETVOLUME???
s16 VolTrg_Left;		// 0x0010(T8)
s32 VolRamp_Left;	// m_LeftVolTarget
s16 VolTrg_Right;	// m_RightVol
s32 VolRamp_Right;	// m_RightVolTarget
s16 Env_Dry;		// 0x001C(T8)
s16 Env_Wet;		// 0x001E(T8)

u8 BufferSpace[0x10000];
short hleMixerWorkArea[256];
u16 adpcmtable[0x88];
int firstHLE, goldeneye;

u16 ResampleLUT[0x200] = {
    0x0C39, 0x66AD, 0x0D46, 0xFFDF, 0x0B39, 0x6696, 0x0E5F, 0xFFD8,
    0x0A44, 0x6669, 0x0F83, 0xFFD0, 0x095A, 0x6626, 0x10B4, 0xFFC8,
    0x087D, 0x65CD, 0x11F0, 0xFFBF, 0x07AB, 0x655E, 0x1338, 0xFFB6,
    0x06E4, 0x64D9, 0x148C, 0xFFAC, 0x0628, 0x643F, 0x15EB, 0xFFA1,
    0x0577, 0x638F, 0x1756, 0xFF96, 0x04D1, 0x62CB, 0x18CB, 0xFF8A,
    0x0435, 0x61F3, 0x1A4C, 0xFF7E, 0x03A4, 0x6106, 0x1BD7, 0xFF71,
    0x031C, 0x6007, 0x1D6C, 0xFF64, 0x029F, 0x5EF5, 0x1F0B, 0xFF56,
    0x022A, 0x5DD0, 0x20B3, 0xFF48, 0x01BE, 0x5C9A, 0x2264, 0xFF3A,
    0x015B, 0x5B53, 0x241E, 0xFF2C, 0x0101, 0x59FC, 0x25E0, 0xFF1E,
    0x00AE, 0x5896, 0x27A9, 0xFF10, 0x0063, 0x5720, 0x297A, 0xFF02,
    0x001F, 0x559D, 0x2B50, 0xFEF4, 0xFFE2, 0x540D, 0x2D2C, 0xFEE8,
    0xFFAC, 0x5270, 0x2F0D, 0xFEDB, 0xFF7C, 0x50C7, 0x30F3, 0xFED0,
    0xFF53, 0x4F14, 0x32DC, 0xFEC6, 0xFF2E, 0x4D57, 0x34C8, 0xFEBD,
    0xFF0F, 0x4B91, 0x36B6, 0xFEB6, 0xFEF5, 0x49C2, 0x38A5, 0xFEB0,
    0xFEDF, 0x47ED, 0x3A95, 0xFEAC, 0xFECE, 0x4611, 0x3C85, 0xFEAB,
    0xFEC0, 0x4430, 0x3E74, 0xFEAC, 0xFEB6, 0x424A, 0x4060, 0xFEAF,
    0xFEAF, 0x4060, 0x424A, 0xFEB6, 0xFEAC, 0x3E74, 0x4430, 0xFEC0,
    0xFEAB, 0x3C85, 0x4611, 0xFECE, 0xFEAC, 0x3A95, 0x47ED, 0xFEDF,
    0xFEB0, 0x38A5, 0x49C2, 0xFEF5, 0xFEB6, 0x36B6, 0x4B91, 0xFF0F,
    0xFEBD, 0x34C8, 0x4D57, 0xFF2E, 0xFEC6, 0x32DC, 0x4F14, 0xFF53,
    0xFED0, 0x30F3, 0x50C7, 0xFF7C, 0xFEDB, 0x2F0D, 0x5270, 0xFFAC,
    0xFEE8, 0x2D2C, 0x540D, 0xFFE2, 0xFEF4, 0x2B50, 0x559D, 0x001F,
    0xFF02, 0x297A, 0x5720, 0x0063, 0xFF10, 0x27A9, 0x5896, 0x00AE,
    0xFF1E, 0x25E0, 0x59FC, 0x0101, 0xFF2C, 0x241E, 0x5B53, 0x015B,
    0xFF3A, 0x2264, 0x5C9A, 0x01BE, 0xFF48, 0x20B3, 0x5DD0, 0x022A,
    0xFF56, 0x1F0B, 0x5EF5, 0x029F, 0xFF64, 0x1D6C, 0x6007, 0x031C,
    0xFF71, 0x1BD7, 0x6106, 0x03A4, 0xFF7E, 0x1A4C, 0x61F3, 0x0435,
    0xFF8A, 0x18CB, 0x62CB, 0x04D1, 0xFF96, 0x1756, 0x638F, 0x0577,
    0xFFA1, 0x15EB, 0x643F, 0x0628, 0xFFAC, 0x148C, 0x64D9, 0x06E4,
    0xFFB6, 0x1338, 0x655E, 0x07AB, 0xFFBF, 0x11F0, 0x65CD, 0x087D,
    0xFFC8, 0x10B4, 0x6626, 0x095A, 0xFFD0, 0x0F83, 0x6669, 0x0A44,
    0xFFD8, 0x0E5F, 0x6696, 0x0B39, 0xFFDF, 0x0D46, 0x66AD, 0x0C39
};

void (*ABI[0x20])  ();

static int audio_ucode_detect(OSTask_t * task)
{

    if ((*(uint8_t *) (N64MEM + task->ucode_data)) != 0x1) {
	if ((*(uint8_t *) (N64MEM + task->ucode_data)) == 0xF)
	    return 4;
	else
	    return 3;
    } else {
	if ((*(uint32_t *) (N64MEM + task->ucode_data + 0x30)) ==
	    0xF0000F00) {
	    if ((*(uint32_t *) (N64MEM + task->ucode_data + 0x28)) ==
		0x1dc8138c)
		return 5;	//goldeneye
	    else
		return 1;

	} else
	    return 2;
    }
}

int audio_ucode(OSTask_t * task)
{

    unsigned int i;

    goldeneye = 0;

    switch (audio_ucode_detect(task)) {
    case 1:			// mario ucode
	memcpy(ABI, ABI1, sizeof(ABI[0]) * 0x20);
	//cprintf("Ucode1\n");
	break;
    case 2:			// banjo kazooie ucode
	memcpy(ABI, ABI2, sizeof(ABI[0]) * 0x20);
	//cprintf("Ucode2\n");
	break;
    case 3:			// zelda ucode
	memcpy(ABI, ABI3, sizeof(ABI[0]) * 0x20);
	//cprintf("Ucode3\n");
	break;
    case 5:
	goldeneye = 1;
	memcpy(ABI, ABI1, sizeof(ABI[0]) * 0x20);
	break;
    default:
	{

	    return -1;
	}
    }

    for (i = 0; i < (task->data_size / 4); i += 2) {
	inst1 = (*(uint32_t *) (N64MEM + task->data_ptr + (i * 4)));
	inst2 = (*(uint32_t *) (N64MEM + task->data_ptr + ((i + 1) * 4)));
	//printf("%x\t%x\n",inst1 >> 24,inst1);
	ABI[inst1 >> 24] ();

    }

    return 0;
}
